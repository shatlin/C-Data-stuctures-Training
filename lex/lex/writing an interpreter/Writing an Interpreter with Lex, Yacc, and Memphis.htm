<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0049)http://memphis.compilertools.net/interpreter.html -->
<HTML><HEAD><TITLE>Writing an Interpreter with Lex, Yacc, and Memphis</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1256">
<META 
content="C/C++, lex and Yacc, scanner, parser, abstract syntax,&#10;trees, tree, builder, tree walker, pattern matching,&#10;compiler construction, language translation" 
name=keywords>
<META 
content="Explains how to write an interpreter for little programming language" 
name=description>
<META content="MSHTML 6.00.2800.1106" name=GENERATOR></HEAD>
<BODY bgColor=#f9c674>
<TABLE cellSpacing=20>
  <TBODY>
  <TR>
    <TD><IMG 
      src="Writing an Interpreter with Lex, Yacc, and Memphis_files/croco.gif"> 
    </TD>
    <TD vAlign=top align=left><A 
      href="http://memphis.compilertools.net/index.html">The Memphis Tree 
      Builder &amp; Tree Walker Tool</A> 
      <H1>Writing an Interpreter<BR>with Lex, Yacc, and Memphis </H1></TD></TR>
  <TR><!-- MENU -->
    <TD vAlign=top align=middle><FONT face=helvetica><A 
      href="http://memphis.compilertools.net/index.html">Memphis</A> <BR><A 
      href="http://memphis.compilertools.net/examples.html">Examples</A> <BR><A 
      href="http://memphis.compilertools.net/manuals.html">Manuals</A> <BR><A 
      href="http://memphis.compilertools.net/distribution.html">Distribution</A> 
      </FONT>
      <P></P></TD><!-- MAINPART -->
    <TD><!-- ======================================================================= -->Here 
      is a small example that shows how to write an interpreter with Lex, Yacc, 
      and Memphis. 
      <P>Our example language provides arithmetic and relational expressions as 
      well as assignment and print statements. To structure programs it features 
      conditional and repetitive statements and the possibility to group 
      statements to sequences. 
      <P>Here is a typical program in our example language: 
      <P><PRE>   // Greatest Common Divisor
   x := 8;
   y := 12;
   WHILE x != y DO
      IF x &gt; y THEN x := x-y
      ELSE y := y-x
      FI
   OD;
   PRINT x
</PRE>
      <P>Our processor for this language will be decomposed into two parts. 
      <P>The task of the first part (the <B>analizer</B>) is to read the source 
      program and to discover its structure. 
      <P>The task of the second part (the <B>tree walker</B>) is to process this 
      structure, thereby evaluating expressions and executing statements. 
      <P>The <B>glue</B> between these parts is an abstract program 
      representation. 
      <H2>The Analizer</H2>The task to structure the program is decomposed into 
      lexical analysis and syntactical analysis. 
      <P><B>Lexical analysis</B> splits the source text into a sequence of 
      tokens, skipping blanks, newlines, and comments. For example, the source 
      text 
      <P><PRE>   x :=   // multiply x
   x*100  // by hundred
</PRE>
      <P>is handled as the sequence of tokens <PRE>   x
   :=
   x
   *
   100
</PRE>
      <P>Each token belongs to a token class. There are simple tokens such as 
      ``<TT>:=</TT>'', it belongs to the class <TT>ASSIGN</TT> which has only 
      this member. And there are more complex tokens such <TT>100</TT>, it 
      belongs to the class <TT>Number</TT> which comprises the strings that form 
      decimal numbers. Simple tokens can be specified simply by the string that 
      represents them. Complex tokens are defined by a <I>regular expression</I> 
      that covers the strings of the token class. For example, the regular 
      expression 
      <P><PRE>   [0-9]+
</PRE>
      <P>specifies nonempty sequences of decimal digits. In case of simple 
      tokens we just need to know the token class, in case of complex tokens 
      some additional processing is neccessary. E.g. the strings that matches 
      the regular expression for numbers must be converted to an integer that 
      holds its numerical value. 
      <P>The lexical analysis is implemented by a function <TT>yylex()</TT> that 
      reads a token from the input stream and returns its name (token class). In 
      addition, it assign the semantic value (e.g. of numbers) to the global 
      variable <TT>yylval</TT>. 
      <P>Such a function can be generated by the tool Lex. Its input is a set of 
      pairs <PRE>regular-expression { action }
</PRE>The action is performed when the current input matches the regular 
      expression. For example, 
      <P><PRE>   ":=" { return ASSIGN; }
</PRE>
      <P>defines <TT>ASSIGN</TT> tokens and 
      <P><PRE>   [0-9]+ { yylval = atoi(yytext); return NUMBER; }
</PRE>
      <P>specifies how to handle numbers. 
      <P>Here is the input to Lex: 
      <P>
      <TABLE>
        <TBODY>
        <TR>
          <TD bgColor=white><FONT size=-2><PRE><P>
   %{
   #include "y.tab.h"
   extern int yylval;
   %}
   %%
   "="      { return EQ; }
   "!="     { return NE; }
   "&lt;"      { return LT; }
   "&lt;="     { return LE; }
   "&gt;"      { return GT; }
   "&gt;="     { return GE; }
   "+"      { return PLUS; }
   "-"      { return MINUS; }
   "*"      { return MULT; }
   "/"      { return DIVIDE; }
   ")"      { return RPAREN; }
   "("      { return LPAREN; }
   ":="     { return ASSIGN; }
   ";"      { return SEMICOLON; }
   "IF"     { return IF; }
   "THEN"   { return THEN; }
   "ELSE"   { return ELSE; }
   "FI"     { return FI; }
   "WHILE"  { return WHILE; }
   "DO"     { return DO; }
   "OD"     { return OD; }
   "PRINT"  { return PRINT; }
   [0-9]+   { yylval = atoi(yytext); return NUMBER; }
   [a-z]    { yylval = yytext[0] - 'a'; return NAME; }   
   \        { ; }
   \n       { nextline(); }
   \t       { ; }
   "//".*\n { nextline(); }
   .        { yyerror("illegal token"); }
   %%
   #ifndef yywrap
   yywrap() { return 1; }
   #endif

</P></PRE></FONT></TD></TR></TBODY></TABLE>
      <P><B>Syntactical analysis</B> imposes a hierarchical structure on the 
      program. This structure is specified by the rules of a <I>context-free 
      grammar</I>. A syntactical phrase is introduced by giving one or more 
      alternatives. An alternative specifies how to construct an instance of the 
      phrase. It list the members that build up the phrase, where such a member 
      is either atoken or the name of a phrase (a <I>nonterminal</I>). 
      <P>Consider the rule to define <TT>statement</TT>s: 
      <P><PRE>   statement:
     designator ASSIGN expression
   | PRINT expression
   | IF expression THEN stmtseq ELSE stmtseq FI
   | IF expression THEN stmtseq FI
   | WHILE expression DO stmtseq OD
   ;
</PRE>
      <P>For example, the first alternative specifies that if <I>D</I> is a 
      <TT>designator</TT> and if <I>E</I> is an <TT>expression</TT> then 
      <I>D</I> <TT>:=</TT> <I>E</I> is a <TT>statement</TT>. 
      <P>We use the tool Yacc to generate the syntactical analizer. Its input is 
      a context-free grammar from which it creates a function <TT>yyparse()</TT> 
      that parses the source text according to that grammar. (<TT>yyparse()</TT> 
      invokes <TT>yylex()</TT> to obtain the next token). 
      <P>With rules like the one given above, <TT>yyparse()</TT> would only be 
      able to check whether a given source is consistent with the grammar. As we 
      did with the Lex specification, we attach semantic actions. They are 
      executed whenever an alternative matches a phrase of the input and are 
      used to construct an abstract program representation. 
      <P>The rule for <TT>statement</TT> becomes: 
      <P><PRE> statement:
   designator ASSIGN expression {$$ = assignment($1, $3);} 
 | PRINT expression {$$ = print($2);} 
 | IF expression THEN stmtseq ELSE stmtseq FI
     {$$ = ifstmt($2, $4, $6);}
 | IF expression THEN stmtseq FI
     {$$ = ifstmt($2, $4, empty());}
 | WHILE expression DO stmtseq OD {$$ = whilestmt($2, $4);}
 ;
</PRE>
      <P>Consider again the first alternative. The semantic action attached to 
      it constructs an abstract representation of an assignment statement and 
      defines this as the structural value of the phrase, i.e. it assigns it to 
      the special variable <TT>$$</TT>. the value is constructed by applying the 
      function <TT>assignment()</TT> to the value of the first member 
      (<TT>designator</TT>), denoted by <TT>$1</TT>, and the value of the third 
      member (<TT>expression</TT>), denoted by <TT>$3</TT>. 
      <P>Here is the input to Yacc: 
      <P>
      <TABLE>
        <TBODY>
        <TR>
          <TD bgColor=white><FONT size=-2><PRE><P>
   %start ROOT

   %token EQ
   %token NE
   %token LT
   %token LE
   %token GT
   %token GE
   %token PLUS
   %token MINUS
   %token MULT
   %token DIVIDE
   %token RPAREN
   %token LPAREN
   %token ASSIGN
   %token SEMICOLON
   %token IF
   %token THEN
   %token ELSE
   %token FI
   %token WHILE
   %token DO
   %token OD
   %token PRINT
   %token NUMBER
   %token NAME

   %%

   ROOT:
     stmtseq { execute($1); } 
   ;

   statement:
     designator ASSIGN expression { $$ = assignment($1, $3); } 
   | PRINT expression { $$ = print($2); } 
   | IF expression THEN stmtseq ELSE stmtseq FI
	{ $$ = ifstmt($2, $4, $6); }
   | IF expression THEN stmtseq FI
	{ $$ = ifstmt($2, $4, empty()); }
   | WHILE expression DO stmtseq OD { $$ = whilestmt($2, $4); }   
   ;

   stmtseq:
     stmtseq SEMICOLON statement { $$ = seq($1, $3); }
   | statement { $$ = $1; }
   ;

   expression:
     expr2 { $$ = $1; } 
   | expr2 EQ expr2 { $$ = eq($1, $3); }
   | expr2 NE expr2 { $$ = ne($1, $3); }
   | expr2 LT expr2 { $$ = le($1, $3); }
   | expr2 LE expr2 { $$ = le($1, $3); }
   | expr2 GT expr2 { $$ = gt($1, $3); }
   | expr2 GE expr2 { $$ = gt($1, $3); }
   ;

   expr2:
     expr3 { $$ == $1; }
   | expr2 PLUS expr3 { $$ = plus($1, $3); }
   | expr2 MINUS expr3 { $$ = minus($1, $3); }
   ;

   expr3:
     expr4 { $$ = $1; }
   | expr3 MULT expr4 { $$ = mult($1, $3); }
   | expr3 DIVIDE expr4 { $$ = divide ($1, $3); }
   ;

   expr4:
     PLUS expr4 { $$ = $2; }
   | MINUS expr4 { $$ = neg($2); }
   | LPAREN expression RPAREN { $$ = $2; }
   | NUMBER { $$ = number($1); }
   | designator { $$ = $1; }
   ;

   designator:
     NAME { $$ = name($1); }
   ;

</P></PRE></FONT></TD></TR></TBODY></TABLE>
      <H2>The Glue</H2>As we have seen with <TT>assignment()</TT>, the abstract 
      representation, or <I>abstract syntax</I>, is constructed by functions 
      that take the representation of constituents and build the representation 
      of a larger construct. 
      <P>This results in a tree structure: the functions construct nodes whose 
      childs are subtrees representing the constituents. 
      <P>In language processors the abstract syntax plays a central role. It 
      does not only define the glue between passes, it also determines the 
      design of functions that process the program: they often inductively 
      follow the structure of the abstract representation. 
      <P>Hence it is a good idea to provide a clean definition. We classify the 
      nodes into into node types and list the types of its childs. 
      <P>For our example language we introduce two node types: 
      <TT>Statement</TT> and <TT>Expression</TT>. An example of nodes of type 
      <TT>Statement</TT> is <TT>assignment</TT> that takes two arguments 
      (<TT>lhs</TT> and <TT>rhs</TT>) of type <TT>Expression</TT>. This is 
      specified by listing 
      <P><PRE>   assignment (Expression lhs, Expression rhs)
</PRE>
      <P>as an alternative of type <TT>Statement</TT>. 
      <P>We use domain declarations for the specification. 
      <P>For example, <TT>Statement</TT> is introduced by a declaration of the 
      form 
      <P><PRE>   domain Statement {
      ...
   }
</PRE>
      <P>that lists the <TT>Statement</TT> alternatives. One of them is 
      <P><PRE>   assignment (Expression lhs, Expression rhs)
</PRE>
      <P>Here is the complete definition of the abstract syntax: 
      <P>
      <TABLE>
        <TBODY>
        <TR>
          <TD bgColor=white><FONT size=-2><PRE>
   domain Statement {

      assignment (Expression lhs, Expression rhs)
      print (Expression x)
      ifstmt (Expression cond, Statement thenpart, Statement elsepart)   
      whilestmt (Expression cond, Statement body)
      seq (Statement s1, Statement s2)
      empty ()

   }

   domain Expression {

      eq (Expression x, Expression y)
      ne (Expression x, Expression y)
      lt (Expression x, Expression y)
      le (Expression x, Expression y)
      gt (Expression x, Expression y)
      ge (Expression x, Expression y)
      plus (Expression x, Expression y)
      minus (Expression x, Expression y)
      mult (Expression x, Expression y)
      divide (Expression x, Expression y)
      neg (Expression x)
      number (int x)
      name (int location)

   }

</PRE></FONT></TD></TR></TBODY></TABLE>
      <P>Note that this definition can be read as a grammar defining the 
      abstract syntax. 
      <P>The definition not only provides documentation (as it is valuable even 
      if we write the corresponding C/C++ data types and the functions 
      manually), it also enables the Memphis precompiler to generate the 
      implementation automatically. 
      <H2>The Tree Walker</H2>We are now ready to write the tree walker. 
      <P>It will consist of two functions (one for each domain of the abstract 
      syntax): <TT>evaluate (Expression e)</TT> that evaluates an 
      <TT>Expression</TT> <TT>e</TT> and returns its numerical value, and 
      <TT>execute (Statement s)</TT> that executes a <TT>Statement</TT> 
      <TT>s</TT>. 
      <P>Such functions are generally written by providing a piece of code for 
      each possible alternative of the argument, where this code recursively 
      visits the constituents the argument. 
      <P>In Memphis we can use the <TT>match</TT> statement to describe this 
      style of processing. 
      <P>The <TT>evaluate</TT> function takes the form 
      <P><PRE>   int evaluate(Expression e)
   {
      match e {
         ...
      }
   }
</PRE>
      <P>The body of the <TT>match</TT> statement lists specific rules that 
      handle the <TT>Expression</TT> <TT>e</TT> according to its structure. 
      <P>One of these rules is 
      <P><PRE>   rule plus(x, y) : return evaluate(x) + evaluate(y);
</PRE>
      <P>If <TT>e</TT> has the form <TT>plus(x, y)</TT> then this rule is 
      applied. It recursively evaluates <TT>x</TT> and <TT>y</TT> and returns 
      the sum of their numerical values. 
      <P>Here is the tree walker: 
      <P>
      <TABLE>
        <TBODY>
        <TR>
          <TD bgColor=white><FONT size=-2><PRE>
   with ast;

   extern "C" printf(...);
   extern "C" execute(Statement s);

   int var[26];

   int evaluate(Expression e)
   {
      match e {
	 rule eq(x, y)     :  return evaluate(x) == evaluate(y);   
	 rule ne(x, y)     :  return evaluate(x) != evaluate(y);
	 rule lt(x, y)     :  return evaluate(x) &lt;  evaluate(y);
	 rule le(x, y)     :  return evaluate(x) &lt;= evaluate(y);
	 rule gt(x, y)     :  return evaluate(x) &gt;  evaluate(y);
	 rule ge(x, y)     :  return evaluate(x) &gt;= evaluate(y);
	 rule plus(x, y)   :  return evaluate(x) +  evaluate(y);
	 rule minus(x, y)  :  return evaluate(x) -  evaluate(y);
	 rule mult(x, y)   :  return evaluate(x) *  evaluate(y);
	 rule divide(x, y) :  return evaluate(x) /  evaluate(y);
	 rule neg(x)       :  return - evaluate(x);
	 rule number(x)    :  return x;
	 rule name(x)      :  return var[x];
      }
   }

   execute (Statement s)
   {
      match s {
	 rule assignment(name(x), rhs) :
	    var[x] = evaluate(rhs);
	 rule print(x) :
	    printf("%d\n", evaluate(x));
	 rule ifstmt(c, s1, s2) :
	    if(evaluate(c)) execute(s1); else execute(s2);
	 rule whilestmt(c, s) :
	    while(evaluate(c)) execute(s);
	 rule seq(s1, s2) :
	    execute(s1); execute(s2);
	 rule empty() :
	    ;
      }
   }

</PRE></FONT></TD></TR></TBODY></TABLE>
      <P>Note that this notation is similar to the Yacc style. A syntactic 
      pattern is followed by an associated action. But here the pattern 
      describes abstract syntax instead of concrete source text. 
      <P>Again, the notation is more concise than the corresponding manual 
      implementation. The Memphis precompiler not only generates the 
      implementation, it also allows to check statically that constituents are 
      only used in a context where they are indeed fields of the actual item. <!-- ======================================================================= --></P></TD><!-- END MAINPART --></TR></TBODY></TABLE></BODY></HTML>
